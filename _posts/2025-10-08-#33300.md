---
layout: pr
date: 2025-10-08
title: "Compact block harness"
pr: 33300
authors: [Crypt-iQ]
components: ["tests"]
host: marcofleon
status: upcoming
commit: ed813c48f826d083becf93c741b483774c850c86
---

## Notes

- This PR adds a [fuzz harness](#fuzz-testing) for testing [compact block relay](#compact-blocks-protocol-overview), along with a few test infrastructure changes to improve speed and stability. Earlier review clubs on fuzzing include: [#17860](./17860), [#18521](./18521), [#21142](./21142), [#30605](./30605). 

- The harness simulates P2P network behavior by having three peers send various messages (CMPCTBLOCK, BLOCKTXN, HEADERS, SENDCMPCT, TX) to the test node, triggering its compact block logic.
 
- The goal is to find bugs and ensure assertions hold. See [#33296](https://github.com/bitcoin/bitcoin/pull/33296) for an example of a bug found by this very fuzz test. Nice!


### Compact Blocks Protocol Overview

- [BIP 152](https://github.com/bitcoin/bips/blob/master/bip-0152.mediawiki) introduced the [compact block relay protocol](https://bitcoinops.org/en/topics/compact-block-relay/), which reduces bandwidth and latency when propagating blocks by sending an encoded version of a block under the assumption that most of the transactions are already in our peer's mempool.

- Compact blocks consist of:
  - A header
  - Short transaction identifiers (6 bytes instead of 32 bytes)
  - Some transactions in full (pre-filled transactions, just the coinbase tx in production code)

- The receiving node reconstructs the block using transactions from its mempool. If any transactions are missing, it requests them via a `GETBLOCKTXN` message.

- There are two modes:
  - low-bandwidth: block sent only after peer requests it via `INV`/`GETDATA`
  - high-bandwidth: block sent to peers without request as soon as it is received, even before full validation is completed


### Fuzz Testing

- Fuzzing is a testing technique that provides quasi-random inputs to code to discover bugs and unexpected behavior. Fuzzers use feedback like code coverage as a guide for mutation of those inputs, allowing them to explore deeper paths within the target code.

- See our [fuzzing docs](https://github.com/bitcoin/bitcoin/blob/master/doc/fuzzing.md) to start fuzzing with libFuzzer and AFL++.

- Check out this PR's [test coverage](https://marcofleon.github.io/coverage/cmpctblock/) (`blockencodings.cpp` and `net_processing.cpp` are probably most useful to look at). Walking through a coverage report to see which branches are hit or not hit is a good way to start evaluating a fuzz harness.

- An effective fuzz test must be deterministic, to make bugs reproducible. If you’re able to get the AFL++ fuzzer running, you will see a stability metric. The goal is to get to 100%, perfect determinism! After gathering some inputs, you can also run the [fuzz determinism script](https://github.com/bitcoin/bitcoin/blob/master/contrib/devtools/deterministic-fuzz-coverage/src/main.rs) over the corpus to check for potential sources of instability.


## Fun Exercise

- If you get the `cmpctblock` harness running, revert PR [#33296](https://github.com/bitcoin/bitcoin/pull/33296) and see if you can reproduce the crash on this [`Assume`](https://github.com/bitcoin/bitcoin/blob/689a32197638e92995dd8eb071425715f5fdc3a4/src/net_processing.cpp#L3333) statement.

- Yeah I know, fuzzing is cool.


## Questions

1. Did you review the PR? Concept ACK, approach ACK, tested ACK, or NACK? What was your review approach? Were you able to get the fuzz test running?

2. Where in the codebase are the main compact block helpers and processing logic? Name some of the relevant classes and functions. (Hint: nothing like a little search for `NetMsgType::CMPCTBLOCK` to get you started)

3. The fuzz test sends `SENDCMPCT` messages with `high_bandwidth` randomly set. What is the difference between high bandwidth and low bandwidth compact block relay? How many high bandwidth peers are allowed and does the fuzz harness test this limit?

4. Compare `-testdatadir` and the new `-fuzzcopydatadir`. Why is the latter useful for performance, and why isn’t a fresh `TestingSetup` that mines blocks on each iteration acceptable here?

5. Look at `create_block` in the harness. How many transactions do the generated blocks contain, and where do they come from? What compact block scenarios might be missed with only a few transactions in a block?

6. In commit [ecba804](https://github.com/bitcoin/bitcoin/pull/33300/commits/ecba804b0d034bbb6e61510cd2161b2ae449ac8d) `FinalizeHeader` is moved to `util.h` so it can be used by any fuzz test. What does this function do and why doesn’t it stall the fuzzer?

7. Commit [e2f9214](https://github.com/bitcoin/bitcoin/pull/33300/commits/e2f921458913bcbbe74115cdb2174b0ab31784f2) sorts `m_dirty_blockindex` by block hash instead of pointer address. What non-determinism does this fix?  The author [notes](https://github.com/bitcoin/bitcoin/pull/33300#issuecomment-3308381089) this slows production code for no production benefit. Why can't [`EnableFuzzDeterminism()`](https://github.com/bitcoin/bitcoin/blob/acc7f2a433b131597124ba0fbbe9952c4d36a872/src/util/check.h#L34) be used here? How do you think this non-determinism should be best handled (if not the way the PR currently does)?

8. The harness adds pre-filled transactions to a compact block beyond the coinbase (which is all we do in production code for now). Walk through the index calculations for pre-filling transactions at indices 1 and 3 in a 4-transaction block. Do you think this code could be simplified or cleaned up, and if so, what do you suggest?


<!-- TODO: After a meeting, uncomment and add meeting log between the irc tags
## Meeting Log

### Meeting 1

{% irc %}
-->
<!-- TODO: For additional meetings, add the logs to the same irc block. This ensures line numbers keep increasing, avoiding hyperlink conflicts for identical line numbers across meetings.

### Meeting 2

-->
{% endirc %}
