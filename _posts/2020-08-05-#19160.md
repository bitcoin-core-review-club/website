---
layout: pr
date: 2020-08-05
title: "Multiprocess: Add basic spawn and IPC support"
pr: 19160
authors: [ryanofsky]
components: ["build system"]
host: ryanofsky
status: upcoming
commit: 0602f87
---

## Notes

These review club notes are for PR [#19160 multiprocess: Add basic spawn and IPC support](https://github.com/bitcoin/bitcoin/pull/19160) ([branch](https://github.com/ryanofsky/bitcoin/commits/pr/ipc-echo.7)), focused on the second eponymous commit: [`aa4d626`](https://github.com/ryanofsky/bitcoin/commit/aa4d626db1628d5e29572eccfd7fa2d99edeeb60). _IPC_ in the title is short for [Inter-process communication](https://en.wikipedia.org/wiki/Inter-process_communication).

The key things this commit adds are an [`IpcProcess::spawn()`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L24-L26) method, which a bitcoin parent process can call to spawn a new child process, and an [`IpcProcess::serve()`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L31-L33) method, which a bitcoin child process can call [after](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/bitcoind.cpp#L180-L185) [startup](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/bitcoin-wallet.cpp#L82-L88) to communicate back to its parent process.

In follow-up PR [#10102 Multiprocess bitcoin](https://github.com/bitcoin/bitcoin/pull/10102), this functionality is used so a `bitcoin-gui` process can spawn a `bitcoin-node` process, and a `bitcoin-node` process can spawn a `bitcoin-wallet` process, and gui, node, and wallet functionality can run in separate processes that are protected from each other. In further follow-ups [#19460 Add bitcoin-wallet -ipcconnect option](https://github.com/bitcoin/bitcoin/pull/19460) and [#19461 Add bitcoin-gui -ipcconnect option](https://github.com/bitcoin/bitcoin/pull/19461), more flexibility is added so node, wallet, and GUI processes can be started and stopped independently.

All communication between Bitcoin Core processes happens though [internal C++ interfaces](https://github.com/bitcoin/bitcoin/tree/master/src/interfaces), which are just C++ classes with pure virtual methods. The virtual methods allow bitcoin GUI, node, and wallet code to be written in a straightforward way that doesn't require dealing with complications of IPC. IPC is handled by the multiprocess framework added in this PR, to avoid the need to complicate application code with low level I/O.

Specifically, follow-up PR [#10102 Multiprocess bitcoin](https://github.com/bitcoin/bitcoin/pull/10102) uses the IPC framework added here to generate subclasses for each C++ interface class, with every overridden virtual method of every subclass implemented to send method calls and arguments to a remote process, wait for a response, and then return the response as the method return value. For example, if the GUI wants to find out if a wallet address is spendable, it calls the [`interfaces::Wallet::isSpendable()`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/wallet.h#L94-L95) method. If GUI code and wallet code are running in the same process, this directly invokes the [`interfaces::WalletImpl::isSpendable()` method implementation](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/wallet.cpp#L135). But if GUI and wallet code are running in different process, the multiprocess framework instead provides a different (generated) [`interfaces::Wallet`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/wallet.h#L51-L52) class implementation that forwards the method request and arguments to a remote wallet process, waits for the results, and returns them, instead of directly calling wallet code.

The design goal is for cross-process communication to happen through normal method calls, and for node, wallet, and GUI code not to have to change drastically to support process separation.

IPC framework support is added in the second commit [`aa4d626` Add basic spawn and IPC support](https://github.com/ryanofsky/bitcoin/commit/aa4d626db1628d5e29572eccfd7fa2d99edeeb60)
of [#19160](https://github.com/bitcoin/bitcoin/pull/19160), which is then tested in the third commit [`0602f87` Add echoipc RPC method and test](https://github.com/ryanofsky/bitcoin/commit/0602f87a085c733f1da38b3b82210c81ef018fd5) ([branch](https://github.com/ryanofsky/bitcoin/commits/pr/ipc-echo.7)), and finally put to real use in [#10102 Multiprocess bitcoin](https://github.com/bitcoin/bitcoin/pull/10102) ([branch](https://github.com/ryanofsky/bitcoin/commits/pr/ipc.120)). This review is focused on the second framework commit, and the 3 classes introduced there:

- `interfaces::IpcProcess` - [interface](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L14-L34), [implementation](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.cpp#L18-L66)
- `interfaces::IpcProtocol` - [interface](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L36-L72), [implementation](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/capnp/ipc.cpp#L37-L88)
- `interfaces::Init` - [interface](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/init.h#L22-L51), [`bitcoind` implementation](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/init_bitcoind.cpp#L13-L29), [`bitcoin-node` implementation](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/init_bitcoin-node.cpp#L14-L42)

The [`IpcProcess`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L14-L34) class has [`spawn(exe_name, pid)`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L24-L26) and [`serve(exit_status)`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L31-L33) methods and is responsible for spawning new child processes, creating pipes child and parent processes can use to communicate, and passing pipe file descriptors to [`IpcProtocol`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L36-L72) objects in parent and child processes.

The [`IpcProtocol`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L36-L72) class is what actually sends method calls across the pipe, turning every method call into a request and a response, and tracking object lifetimes. The `IpcProcotol` and `IpcProcess` classes could have been melded together into a single class, but separating them allows the spawn and pipe setup code to work with protocols other than [Cap'n Proto](https://capnproto.org/), which is the internal protocol currently used by the `IpcProtocol` class.

The [`Init`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/init.h#L29-L61) interface is similar to other cross-process C++ interfaces like [`interfaces::Node`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/node.h#L45-L276), [`interfaces::Wallet`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/wallet.h#L51-L304), [`interfaces::Chain`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/chain.h#L60-L276) and [`interfaces::ChainClient`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/chain.h#L278-L309), providing virtual methods that can be called from other processes. What makes it special is that unlike other interfaces which are not implemented by every process—`interfaces::Node` is only implemented by the node process and `interfaces::Wallet` is only implemented by the wallet process—`interfaces::Init` is implemented by every process that supports being spawned, and it is the initial interface returned by the [`IpcProtocol::connect(fd)`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L50-L59) method, allowing the parent process to control the child process after the connection is established. The `interfaces::Init` interface has methods that allow the parent process to get access to every interface supported by the child process, and when the parent process frees the `interfaces::Init` object, the child process shuts down.

## Questions

1. The entry points for spawned [`bitcoin-node`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/bitcoind.cpp#L180-L185) and [`bitcoin-wallet`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/bitcoin-wallet.cpp#L82-L88) processes both call [`IpcProcess::serve()`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L31-L33) then immediately exit when it returns. How do the child processes provide useful functionality to the parent processes if they never run the code after the `IpcProcess::serve()` calls?

1. When does the [`IpcProcessImpl::serve()`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.cpp#L35-L61) method return true and when does it return false? Is it ever expected to return false, or is it always an error?

1. The [`IpcProcessImpl::spawn()`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.cpp#L25-L33) implementation has a lambda that generates a vector of command line arguments for the process that should be spawned. What does the generated command line look like, and why does the generated command line for the child process depend on `m_argv[0]` of the parent process? Why does it include a pipe file descriptor (`int fd`).

1. The [`MakeCapnpProtocol(LocalInit& init)`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/capnp/ipc.cpp#L91-L94) function returns an [`IpcProtocolImpl`](https://github.com/ryanofsky/bitcoin/blob/0602f87a085c733f1da38b3b82210c81ef018fd5/src/interfaces/capnp/ipc.cpp#L37-L88) protocol implementation which is a dumb wrapper around [libmultiprocess](https://github.com/chaincodelabs/libmultiprocess/) functions that translate `interfaces::Init` method calls to pipe reads & writes (for a parent process) and translate pipe read & writes to `interfaces::Init` interface method calls (for a child process). If we wanted to replace libmultiprocess and use a different protocol to communicate across the pipe, would the [`interfaces::IpcProtocol`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L36-L72) interface need to change? If communication needed to go to a different channel other than a pipe, like an IP address, or an SSL socket, would the [`interfaces::IpcProtocol`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/ipc.h#L36-L72) interface need to change then? How would it change?

1. The new [`init_bitcoind.cpp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/init_bitcoind.cpp) file introduced in this PR is linked into the `bitcoind` executable and the new [`init_bitcoin-node.cpp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc-echo.7/src/interfaces/init_bitcoin-node.cpp) file is linked into the `bitcoin-node` executable. Without this change, and before this PR, the `bitcoind` and `bitcoin-node` executables were identical. In follow-up PR [#10102 Multiprocess bitcoin](https://github.com/bitcoin/bitcoin/pull/10102) there are more changes to [`init_bitcoind.cpp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/init_bitcoind.cpp) and [`init_bitcoin-node.cpp`](https://github.com/ryanofsky/bitcoin/blob/pr/ipc.120/src/interfaces/init_bitcoin-node.cpp) that give `bitcoin-node` significantly different behavior from `bitcoind`, running wallet code in a new spawned `bitcoin-wallet` process instead of in the same process. In this PR, the differences between `init_bitcoin-node.cpp` and `init_bitcoind.cpp` are more minor, but what are they? Do they lead to differences in observable behavior?

<!-- TODO: After meeting, uncomment and add meeting log between the irc tags
## Meeting Log

{% irc %}
{% endirc %}
-->
