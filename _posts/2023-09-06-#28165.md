---
layout: pr
date: 2023-09-06
title: "transport abstraction"
pr: 28165
authors: [sipa]
components: ["p2p"]
host: glozow
status: upcoming
commit:
---

## Notes

- Bitcoin nodes "speak" a P2P protocol, which includes a way of interpreting bytes sent over
  connections to one another as well as expectations for the contents of those messages peers are expected to send to each
  other. Within Bitcoin Core, the implementations of these two parts of the protocol live in largely
separate areas of the code. At a high level:

    - The ["net processing"](https://github.com/bitcoin/bitcoin/blob/083316c4fe20819fbe627c5d21f1a627e10af329/src/net_processing.h) layer includes application logic such as
      [responding](https://github.com/bitcoin/bitcoin/blob/083316c4fe20819fbe627c5d21f1a627e10af329/src/net_processing.cpp#L4677-L4694)
    to `ping` with a `pong` containing the same nonce and
[disconnecting](https://github.com/bitcoin/bitcoin/blob/083316c4fe20819fbe627c5d21f1a627e10af329/src/net_processing.cpp#L4074-L4077)
a peer that sends a transaction after we told them not to.

    - The ["net"](https://github.com/bitcoin/bitcoin/blob/083316c4fe20819fbe627c5d21f1a627e10af329/src/net.h) layer "below" net processing abstracts away the details of converting
      messages to/from bytes that are sent and received on the connection.

- Within the `ProcessMessage` function which responds to pings with pongs, The `ping` is a
  `CNetMessage` retrieved from `CNode::PollMessage`, and the `pong` is sent by calling
  `CConnman::PushMessage`.

- [`CConnman::SocketSendData`](https://github.com/bitcoin/bitcoin/blob/master/src/net.cpp#L836) is
  the function that actually sends data over the connection. It is called by the [socket handler
thread](https://github.com/bitcoin/bitcoin/blob/083316c4fe20819fbe627c5d21f1a627e10af329/src/net.cpp#L2416)
and sometimes by [message handler
thread](https://github.com/bitcoin/bitcoin/blob/083316c4fe20819fbe627c5d21f1a627e10af329/src/net.cpp#L2441)
from `PushMessage` (an "opportunistic write") if the message queue was empty.

- This PR is a prerequisite of [PR #28196](https://github.com/bitcoin/bitcoin/pull/28196)
  implementing [BIP324](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki). The complete specification of BIP324 is out of scope for this Review Club, but please make sure to read the [Introduction](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-Introduction) and [Goals](https://github.com/bitcoin/bips/blob/master/bip-0324.mediawiki#user-content-Goals).
 
- BIP324 introduces a new transport protocol version. While nodes still send the same types of messages and respond to pings with pongs in the same way, the way messages are converted to/from bytes is very different.

- This PR creates an abstract `Transport` class, combining the current `TransportDeserializer` and
  `TransportSerializer` classes into a single interface for converting bytes to/from messages.

- A combined interface means that `V2Transport` can have state shared between the
serializer and deserializer, such as the `BIP324Cipher` for encrypting/decrypting messages. It may
be helpful to see how `V2Transport` is implemented in that PR.  Also see a [previous
approach](https://github.com/bitcoin/bitcoin/pull/24545), which kept the serializer and deserializer
separate and
[stored](https://github.com/bitcoin/bitcoin/pull/24545/files#diff-422879cc8bfac56d4380c865f381b58afeb344bc355bbc7f47c581e4491b6b4bR551)
state in the `CNode` object.

## Questions

We'll be covering the [General](#general) questions on the first meeting on Wednesday, and the [PR-specific](#pr-specific) questions on the second meeting on Thursday.

### General

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)? What was your review approach?

2. What is the distinction between "net" and "net processing"? What data structures and tasks might
   we associate with each of them?

3. Does BIP324 require changes to the "net" layer, the "net processing" layer, or both? Does it affect policy or consensus?

4. Is {`CNetMessage`, `CMessageHeader`, `CSerializedNetMsg`, `BytesToSend`} used in sending, receiving, or both?

5. `CNetMsgMaker` and `Transport` both "serialize" messages. What is the difference in what they do?

6. In the process of turning an application object like a `CTransactionRef` into bytes sent over the
   wire, what needs to happen? What data structures are involved? (Hint: start
[here](https://github.com/bitcoin/bitcoin/blob/ab42b2ebdbf61225e636e4c00068fd29b2790d41/src/net_processing.cpp#L2334-L2335),
where a transaction is sent in response to a `getdata`, and trace the calls until [this
line](https://github.com/bitcoin/bitcoin/blob/ab42b2ebdbf61225e636e4c00068fd29b2790d41/src/net.cpp#L949)
calling `Sock::Send`).

7. The RPC `getpeerinfo` returns a map of `bytessent_per_msg` and `bytesrecv_per_msg`. Add a
`print(self.nodes[0].getpeerinfo()[0]['bytessent_per_msg'])` to one of the subtests in test/functional/p2p_sendtxrcncl.py after peers send `sendtxrcncl` to each other, e.g. [here](https://github.com/bitcoin/bitcoin/blob/ab42b2ebdbf61225e636e4c00068fd29b2790d41/test/functional/p2p_sendtxrcncl.py#L75). BIP 330 [specifies](https://github.com/bitcoin/bips/blob/master/bip-0330.mediawiki#user-content-sendtxrcncl) that peers send only 1 "sendtxrcncl" message to each other, and each consists of a 4B version and a 8B salt, but `getpeerinfo`will report a number much higher than 12B. What is the number, and what is included in those bytes?
   (Hint: see
[`AccountForSentBytes`](https://github.com/bitcoin/bitcoin/blob/ab42b2ebdbf61225e636e4c00068fd29b2790d41/src/net.h#L514). Where is it called?)

8. After `PushMessage` returns (e.g. on [this
   line](https://github.com/bitcoin/bitcoin/blob/ab42b2ebdbf61225e636e4c00068fd29b2790d41/src/net_processing.cpp#L5864)),
have we sent the bytes corresponding to this message to the peer already (yes/no/maybe)? Why?

9. Which threads access `CNode::vSendMsg`? (Hint: start by searching for `vSendMsg` within
   src/net.cpp, then search for the functions which access it, then the functions which call those
functions... until you find where the `std::thread`s are created).

### PR-specific

10. Can you summarize what this PR is doing?

11. What does it mean for
   [`CNetMessage`](https://github.com/bitcoin/bitcoin/blob/ab42b2ebdbf61225e636e4c00068fd29b2790d41/src/net.h#L231-L257)
to be "transport protocol agnostic"?

12. Prior to this PR, why are `TransportSerializer` and `TransportDeserializer` different classes?
   Why should they be combined? What are the downsides to combining them, if any?

13. What is the difference in approach with [#24545](https://github.com/bitcoin/bitcoin/pull/24545)? Do you think this approach is preferable?

14. Commit [`27f9ba23`](https://github.com/bitcoin/bitcoin/pull/28165/commits/27f9ba23efe82531a465c5e63bf7dc62b6a3a8db)
adds an internal `m_recv_mutex` for protecting receiving state. The commit message also mentions
that an *external* mutex is needed. Why? (Hint: is it ok for `vRecv` to change in between calling
`ReceivedMessageComplete` and `GetReceivedMessage`?)

15. At a high level, what does the added [fuzz test](https://github.com/bitcoin/bitcoin/pull/28165/commits/009ff8d65058430d614c9a0e0e6ae931b7255c37) do? What kinds of bugs would it catch? What kinds of bugs would it not catch?

16. Commit
   [`bb4aab90`](https://github.com/bitcoin/bitcoin/pull/28165/commits/bb4aab90fd046f2fff61e082a0c0d01c5ee31297)
moves the code using `m_transport` to convert the message to bytes from `PushMessage` to
`SocketSendData`. What are the behavior changes in this commit?

17. Commit
   [`bb4aab90`](https://github.com/bitcoin/bitcoin/pull/28165/commits/bb4aab90fd046f2fff61e082a0c0d01c5ee31297) mentions "removing the assumption that a message can always immediately be converted to wire bytes." What happens in `SocketSendData` if `m_transport` isn't able to convert messages?

18. Commit [`bb4aab90`](https://github.com/bitcoin/bitcoin/pull/28165/commits/bb4aab90fd046f2fff61e082a0c0d01c5ee31297) mentions one thread being "more of a computational bottleneck" than the other. Which thread is this, and what runs on it?

<!-- TODO: After a meeting, uncomment and add meeting log between the irc tags.
## Meeting Log

### Meeting 1

{% irc %}
-->
<!-- TODO: For additional meetings, add the logs to the same irc block. This ensures line numbers keep increasing, avoiding hyperlink conflicts for identical line numbers across meetings.
### Meeting 2

-->
{% endirc %}
