---
layout: pr
date: 2025-08-06
title: "wallet: Add exportwatchonlywallet RPC"
pr: 32489
authors: [achow101]
components: ["wallet", "rpc"]
host: ryanofsky
status: upcoming
commit: e6ac2015a852
---

## Notes

### Motivation & user story
* Air-gapped (“signing”) machines hold the private keys; an online (“watch-only”) node tracks balances, generates receive addresses, and prepares PSBTs.
  Today users must **manually** recreate that watch-only wallet by typing or scripting `importdescriptors`, copying address labels, etc.
* `exportwatchonlywallet` provides a **single-step** RPC that produces a wallet file containing:
  * All *public* descriptors (& caches when needed)
  * Address book entries, receive-request metadata, and “avoid-reuse” markers
  * All wallet TXs (so rescans are unnecessary)
  * Persisted locked-coin state and wallet flags
  * **No private keys** (wallet is created with `WALLET_FLAG_DISABLE_PRIVATE_KEYS`)

The result can be moved to any node and loaded with the existing `restorewallet` RPC.

---

### New building blocks introduced in this PR

| Area | New API / behaviour | Why it is needed |
|------|--------------------|------------------|
| **Descriptors** | `Descriptor::CanSelfExpand()` plus plumbing in every `DescriptorImpl` and `PubkeyProvider` | Lets the wallet know whether a descriptor can generate new scriptPubKeys *without* a cache **and** without private keys. Hardened paths (e.g. `/0h/*`) return *false*. |
| **Wallet internals** | `CWallet::ExportDescriptors(bool export_private)` | Moves descriptor enumeration logic out of `listdescriptors` RPC so it can be reused by the exporter. |
| | `CWallet::ExportWatchOnlyWallet(const fs::path& dst, WalletContext&)` | Creates a *temporary* watch-only wallet DB, populates it, backs it up to `dst`, then deletes the temp directory. This keeps the exported file self-contained and avoids leaving stray wallet dirs around. |
| **RPC** | `exportwatchonlywallet <destination>` | Thin wrapper around the method above. |
| **Tests** | `wallet_exported_watchonly.py` functional test | Exercises basic export, address-book copy, tx / lock copy, imported descriptors, avoid-reuse flag, encrypted source wallets. |

---

### Walk-through of the export algorithm (very high level)

1. **Pre-flight checks** – ensure destination path does not exist; grab a canonical path; hold `cs_wallet`.
2. **Gather descriptor data** using `ExportDescriptors(false)`.
3. **Instantiate** a *new* wallet DB with the *same* flags ∪ `WALLET_FLAG_DISABLE_PRIVATE_KEYS`.
4. **Populate** the new wallet inside a single batch TX:
   * Add each descriptor as a `DescriptorScriptPubKeyMan`.
     * If `!desc->CanSelfExpand()`, copy the source descriptor **cache** first, so address generation works.
   * Copy active SPKMs / internal flags so it knows which pools to use.
   * Copy persistent locked coins, address-book rows, receive-requests, “previously-spent” markers, `nOrderPosNext`, and best-block locator (to avoid rescan).
   * Copy every `CWalletTx` so balances are immediately correct.
5. **Backup** the new wallet to the requested `destination` and then delete the temp directory.
6. Return the fully-qualified path in the RPC result.

---

### Behavioural quirks & edge-cases worth reviewing

* **Hardened xpub paths** – these cannot self-expand; exporter copies the cache so watch-only wallet can derive addresses up to the last used index but cannot extend indefinitely.
* **Encrypted source wallets** – exporter runs while the wallet is locked because it never reads private keys.
* **Avoid-reuse & address-book flags** – exporter must preserve *both* the wallet flag and the special “previously spent” metadata to keep behaviour identical.
* **Tx ordering & `nOrderPosNext`** – ensures recreated wallet doesn’t reshuffle history.
* **Concurrency** – every path that reads mutable wallet state is executed under `cs_wallet`; temp wallet is manipulated under its own lock *and* inside a batch DB TX.

---

## Questions

1. **Review approach** Did you test, concept ACK, approach ACK, or NACK the PR?  What aspects did you focus on during review?
1. **Descriptor API** Why can’t the existing `IsRange()`/`IsSingleType()` information tell us whether a descriptor can be expanded on the watch-only side?  Explain the logic behind `CanSelfExpand()` for
   a) a hardened `wpkh(xpub/0h/*)` path and
   b) a `pkh(pubkey)` descriptor.
1. **Cache copying** `ExportWatchOnlyWallet` only copies the descriptor cache *if* `!desc->CanSelfExpand()`.
   *What exactly is stored in that cache?* How could an incomplete cache affect address derivation on the watch-only wallet?
1. **Wallet flags** The exporter sets `create_flags = GetWalletFlags() | WALLET_FLAG_DISABLE_PRIVATE_KEYS`.
   Why is it important to preserve the original flags (e.g. `AVOID_REUSE`) instead of clearing everything and starting fresh?
1. **Best-block locator** Why does the exporter read the locator from the *source* wallet and write it verbatim into the new wallet instead of letting the new wallet start from block 0?
1. **Security / privacy** Consider a multisig descriptor `wsh(multi(2,xpub1,xpub2))`.
   If one cosigner exports a watch-only wallet and shares it with a third party, what *new* information does that third party learn compared to just giving them the descriptor strings?
1. **Functional test** In `wallet_exported_watchonly.py`, why does the test call `wallet.keypoolrefill(100)` before checking spendability across the online/offline pair?
1. **Alternatives** Prior to this PR, users could achieve a watch-only setup via `dumpwallet` → `importwallet` or `importdescriptors`.
    Compare those approaches with `exportwatchonlywallet` in terms of UX, completeness, and long-term maintainability.

<!-- TODO: After a meeting, uncomment and add meeting log between the irc tags
## Meeting Log

{% irc %}
{% endirc %}
-->
