---
layout: pr
date: 2023-08-02
title: "[silent Payments]: Base functionality"
pr: 27827
authors: [josibake]
components: ["wallet"]
host: josibake
status: upcoming
commit:
---

## Notes

This PR implements [BIP352: Silent Payments](https://github.com/bitcoin/bips/pull/1458) in the Bitcoin Core wallet. BIP352 is "a protocol for static payment addresses in Bitcoin without on-chain linkability of payments or a need for on-chain notifications."

Before reviewing the PR, it is _strongly_ recommended that you read the [BIP](https://github.com/bitcoin/bips/pull/1458), as well as the [reference implementation](https://github.com/bitcoin/bips/blob/cfe0771a0408a2d2de278d4e95bb9a33bd1615b2/bip-0352/reference.py) and [test vectors](https://github.com/bitcoin/bips/blob/cfe0771a0408a2d2de278d4e95bb9a33bd1615b2/bip-0352/send_and_receive_test_vectors.json). This PR implements the base functionality: sending and receiving. Additional features and broader RPC support are left for follow up PRs. The PR is heavily based on a proof of concept PR, so this PR review club will be primarily focused on:

* Does this PR correctly implement the BIP?
* How can the code be refactored/improved to better fit Core's architecture and style

As such, this review club is for getting feedback and a lot of the questions will be open ended!

## Questions

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)? What was your review approach?

2. Did you take a look at the reference implementation on the BIP and the unit tests? If so, does the python reference implement the BIP correctly? What test cases could be added?

3. BIP352 allows sending and receiving to be implemented separately. As such, this PR is organized into three main sections: 1) adding the necessary cryptographic primitives, 2) implementing sending, and 3) implementing receiving. What are the advantages of this approach? Does it make sense to split this into multiple PRs? Why or why not?

4. How does the PR create the spend and scan keys? Are there any issues with this approach?

5. Is a descriptor the right approach here? Why or why not? If it is, how would you modify the `sp()` descriptor to correctly implement the BIP?

6. Currently, the PR adds each silent payment output to the wallet as a `rawtr` descriptor. What are the downsides of this approach?

7. Silent payments is a wallet protocol, but there are a few places in the PR where the code is not specific to the wallet. Can you point to an example? How could this be better encapsulated to just the wallet?

<!-- TODO: After meeting 1, uncomment and add meeting log between the irc tags
## Meeting Log

### Meeting 1

{% irc %}
{% endirc %}
-->
<!-- TODO: After meeting 2, uncomment and add meeting log between the irc tags
### Meeting 2

{% irc %}
{% endirc %}
-->
