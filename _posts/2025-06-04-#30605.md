---
layout: pr
date: 2025-06-11
title: "Cluster linearization: separate tests from tests-of-tests"
pr: 30605
authors: [sipa]
components: ["tests"]
host: marcofleon
status: upcoming
commit: d2fc10b64505512a70bed05e7bb21d76c8f748cd
---

## Notes

- A cluster is a group of transactions where some transactions depend on others, forming parent-child relationships. The simplest cluster is a single transaction, and most clusters consist of just a few transactions. However, there can be more complex configurations that form large directed acyclic graphs (with grandparents, siblings, uncles, etc). The current limit on cluster size is 64 transactions.

- At a high level, cluster linearization is the process of sorting the transactions within a given cluster in a way that respects dependencies (parents before children) while maximizing the effective fee rate when considering "chunks" of this ordered list. The goal is to produce an optimal linearization: an ordering with the best possible sequence of chunk fee rates (fee rate profile). This linearization allows miners to include the most profitable transactions first. (for more in-depth reading, see [here](https://delvingbitcoin.org/t/how-to-linearize-your-cluster/303))
    - The data structures and algorithms for cluster linearization can be found in [`cluster_linearize.h`](https://github.com/bitcoin/bitcoin/blob/master/src/cluster_linearize.h). 

- The linearization code is complex and therefore relies on fuzz testing to ensure correctness. Using the wide variety of data generated by the fuzzer to build dependency graphs (`DepGraph` instances) and produce/update linearizations is probably our best bet for finding any subtle bugs or edge cases in the code.

- The `cluster_linearize` fuzz test includes a few helper classes and functions that are used to compare against the actual implementation. The motivation for this PR is to construct new fuzz targets that are used to make sure these helpers work properly. By having dedicated targets that test the test, we can be even more confident that our cluster linearization code is bug-free. Woo!

- Note: the current cluster linearization algorithm may be replaced by a new and improved spanning-forest linearization (SFL) algorithm in the future. SFL is essentially a drop-in replacement, so while the underlying algorithm changes, it doesn't change the tests much. It's outside of the scope of this review club, but you can look at [PR 32545](https://github.com/bitcoin/bitcoin/pull/32545) or [this delving post](https://delvingbitcoin.org/t/spanning-forest-cluster-linearization/1419) if you're interested. 

## Exercise

- Try fuzzing the `clusterlin_linearize` target. You can refer to the [fuzzing docs](https://github.com/bitcoin/bitcoin/blob/master/doc/fuzzing.md) for assistance. Using `--preset=libfuzzer-nosan` will likely make building easier.

- Now change `chunking` to `simple_chunking` at this [line](https://github.com/bitcoin-core-review-club/bitcoin/blob/d2fc10b64505512a70bed05e7bb21d76c8f748cd/src/test/fuzz/cluster_linearize.cpp#L1104) and run the target again.

- After a few minutes, you should see a crash. Welcome to fuzzing. This is a simple example of a tiny bug in the test itself which fuzz testing catches quickly. A lot of the time, a crash happens because something is wrong in the fuzz harness itself, as opposed to a bug in the production code. This is why it can be useful to have targets or assertions that ensure that the fuzz test itself is correct.


## Questions

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)? What was your review approach?

2. What are the two new fuzz targets introduced and what are they testing? In terms of what they're testing, how are they different from the other targets?

3. What are the benefits of separating out the fuzzing of the internal test helpers?

4. Were you able to run the `clusterlin_linearize` target? How many iterations (the first number libFuzzer shows at each line) did it take to produce a crash after making the `s/chunking/simple_chunking/` change?

5. In [commit 2763b75](https://github.com/bitcoin-core-review-club/bitcoin/commit/2763b753c7974c877659fdfa1cfcb6a09e2cd2ac), why was `--iterations_left` moved?

6. In `clusterlin_simple_finder`, when finding a topologically valid subset to remove from the graph, why is it important to set `non_empty` to true? What could happen if we allowed empty sets?

7. In `clusterlin_simple_linearize`, why does the code only verify against all possible permutations when `depgraph.TxCount() <= 8`? What would happen if we tried to do this for larger transaction counts?

8. In [commit 1e4f345](https://github.com/bitcoin-core-review-club/bitcoin/commit/1e4f3452a980744ece8a57bf46c35f44e2aa83a0), when a non-topological permutation is found, the code now fast forwards by reversing part of the permutation. Why does this optimization work, and how many permutations can it skip in the best case?

9. In `SimpleCandidateFinder::FindCandidateSet()`, the algorithm keeps track of two sets for each work unit: `inc` (transactions definitely included) and `und` (transactions that can still be added). Why does it need to track both sets instead of just tracking undecided transactions?

10. What is, no doubt, the coolest way to test code?


<!-- TODO: After a meeting, uncomment and add meeting log between the irc tags
## Meeting Log

### Meeting 1

{% irc %}
-->
<!-- TODO: For additional meetings, add the logs to the same irc block. This ensures line numbers keep increasing, avoiding hyperlink conflicts for identical line numbers across meetings.

### Meeting 2

-->
{% endirc %}
