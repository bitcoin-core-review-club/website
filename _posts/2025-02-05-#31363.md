---
layout: pr
date: 2025-02-05
title: "Cluster mempool: introduce TxGraph"
pr: 31363
authors: [sipa]
components: ["mempool"]
host: glozow
status: past
commit: 3c7732bbbe735d1883cdd1737ec200cab8caa049
---

## Notes

### Cluster Mempool Motivation and Background

Skip this section if you are just interested in reviewing the code and don't need to hear the pitch for why.

The primary goal of [Cluster Mempool](https://bitcoinops.org/en/topics/cluster-mempool/)
(tracked [here](https://github.com/bitcoin/bitcoin/issues/30289)) is to enable the mempool to more
intelligently assess which transactions would be most incentive compatible to keep. In simple terms: "which transactions
would earn a miner the most in fees?" The complexity of incentive compatibility assessment comes from dependencies
between transactions, i.e. where a transaction spends the output of another.

If the motivations for this project are unclear to you, try to spend up to 60min on these reading materials:

- "But aren't fees a trivially small portion of block rewards? Why do we care so much?"
  - One of the biggest problems we want to solve is the asymmetry between how we decide what to evict and what goes into blocks: it's possible
    that [the first transaction we would evict is also the first transaction we would mine](https://github.com/bitcoin/bitcoin/issues/27677#eviction-mining-not-opposite).
  - An original motivation for trying to come up with a metric for "incentive compatibility" was within the context of
    [RBF pinning](https://gist.github.com/glozow/25d9662c52453bd08b4b4b1d3783b9ff#mining-score-of-a-mempool-transaction). Our
current feerate-based approach causes us to reject transactions that would be more incentive compatible, creating
censorship problems.

- "Why is cluster-tracking the solution for incentive compatibility?"
  - [This Delving post](https://delvingbitcoin.org/t/mempool-incentive-compatibility/553) explains why incentive
    compatibility is complicated and why tracking and limiting clusters is necessary for a complete solution.
  - We talked about clusters in previous review club meetings about [auto-bumping unconfirmed UTXOs in coin selection](/26152)
    (which added `CTxMmemPool::GatherClusters`) and [Topologically Restricted Until Confirmation transactions](/25038). As we discussed,
    one of the benefits of TRUC is to have an effective cluster limit within the existing framework of
    ancestor/descendant limits (limit of cluster count 2 is the equivalent of limiting ancestor and
    descendant counts to 2). However, a limit of 2 is quite prohibitive.

Mempool transactions and their dependency relationships can naturally be represented as a directed [graph](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics))
where nodes represent transactions and edges represent UTXO spending relationships. This graph may contain multiple connected
components, each called a _cluster_. A transaction's cluster includes all of the transactions it is connected to, which
can be defined recursively: all parents and children (nodes with an edge to or from this one), each of their parents and children, etc.

Cluster Mempool includes some large work components, including (1) adding cluster linearization algorithms which are
used to order (and thus compare) transactions by incentive compatibility, (2) changing the mempool's internal structure
to enable cluster tracking and always maintain a linearization order, and (3) upgrading RBF, eviction, and mining to
use the improved incentive compatibility assessments. This PR is pretty much only relevant to the second component; you
can review it without knowing anything about the cluster linearization algorithm or specific RBF
rules. The code for the first component has been merged (see [PR #30126](https://github.com/bitcoin/bitcoin/pull/30126)
and its followups), and work-in-progress code for the third component can be found at [PR #28676](https://github.com/bitcoin/bitcoin/pull/28676)).

Here is everything you need to know about linearization for this PR:

- A linearization is _topologically valid_ if it ensures that a parent transaction appears somewhere before its child.
There are often multiple valid linearizations for the same cluster, and linearization L1 is better than L2 if taking the
first N bytes of L1 would yield higher fees than taking the first N bytes of L2. The _optimal_ linearization of a
cluster is better or as good as all the others.
- Computation needed for linearization scales with the size of the cluster, which is why their size needs to be limited.
- A cluster requires re-linearization each time a transaction is added or removed.

If you have more time to spend on background concepts or need more convincing, here is additional _optional_ reading material.

- [BIP 431](https://github.com/bitcoin/bips/blob/master/bip-0431.mediawiki) provides an overview of why RBF pinning
  is problematic and some of the other pieces that come together to address its issues.
- [This Delving post](https://delvingbitcoin.org/t/introduction-to-cluster-linearization/1032) provides an overview of the
  algorithms used in cluster linearization.
- [This Delving post](https://delvingbitcoin.org/t/cluster-mempool-rbf-thoughts/156) discusses how to evaluate
  replacements using feerate diagrams, which are enabled with cluster mempool.

### Background on Mempool Architecture and Interfaces

Skip this section if you are already familiar with current mempool code.

"The Mempool" usually refers to the class [`CTxMemPool`](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/txmempool.h#L303).
This class holds a map of
[`CTxMemPoolEntry`](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/kernel/mempool_entry.h#L79-L106)s
and other supporting data structures. It is responsible for keeping itself
internally consistent. Much of the code is dedicated to dealing with dependency relationships.

Outside of the `CTxMemPool` class, here are the major pieces of mempool functionality to think about
while reviewing cluster mempool:

- [Mempool validation](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/validation.cpp#L437-L1938)
decides what unconfirmed transactions to keep in memory. This code also enforces transaction relay policies.
- [Block connection](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/validation.cpp#L3237-L3240)
removes mempool transactions that would be inconsistent with chainstate.
- [Block disconnection](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/validation.cpp#L296-L390)
(aka reorganization) resubmits the transactions from the previous chain that are no longer in the new chain.
- [Block assembly](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/node/miner.cpp#L107-L428)
(aka mining) fills a block template using mempool transactions, optimizing for fee revenue.
- [Mempool eviction](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/txmempool.cpp#L1158-L1200)
is an internal process that decides what transactions to delete when the memory usage exceeds configured limits. It is
triggered in multiple places, including Mempool validation and Block disconnection.

On master, Bitcoin Core's mempool does not track clusters, but it does track ancestor and descendant sets.
[`CTxMemPoolEntry`](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/kernel/mempool_entry.h#L79-L106)
stores references to its parents and children and tracks the {count, total vsize, total fees} of its ancestor and
descendant sets.  Each time a transaction is added or removed, `CTxMemPool` uses the references to traverse ancestors
and/or descendants recursively, updating the cached ancestor and descendant information.

### Design and Usage with Existing Mempool

While the current (on master) `CTxMemPool` class does not contain a data structure dedicated to storing the graph representation
itself, "the graph already exists" in the form of `CTxMemPoolEntry`'s parent/child references and cached
ancestor/descendant information.

The responsibility of keeping this graph up-to-date and within its specified limits largely belongs to `CTxMemPool`, but
occasionally bleeds out to other areas. For example, in mempool validation, `MemPoolAccept` queries `CTxMemPool` for the
ancestors of a transaction in order to:

- Calculate whether this transaction would exceed the ancestor/descendant limits. However, sometimes, when evaluating a
  replacement, we apply an [RBF Carve Out](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/validation.cpp#L950-L984),
literally increasing the limit by 1, to avoid double-counting the replacement and to-be-replaced transactions. Yuck!
- Check whether a TRUC transaction meets its additional topology restrictions. However we first need to [aggregate the
  in-package and in-mempool ancestors](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/validation.cpp#L1551-L1558).
- When evaluating a package, the precise ancestor/descendant counts of each package transaction and connected mempool
  transactions are not calculated before submission. Instead, the [aggregate package count and
size](https://github.com/bitcoin/bitcoin/blob/1172bc4157eefe80d1aaf0b56459857ec651e535/src/validation.cpp#L1141-L1146) are used. This
approximation avoids complexity, but can result in overestimation for certain topologies.

These examples also illustrate current accuracy problems with enforcing topology limits.

### Design and Usage with TxGraph

[PR #31363](https://github.com/bitcoin/bitcoin/pull/31363)
adds a `TxGraph` class, used by `CTxMemPool` to encapsulate the transaction graph.  The
[PR description](https://github.com/bitcoin/bitcoin/pull/31363#issue-2687950417) provides an
overview of its interface and implementation. `TxGraph` supports "main" and "staged" changes:
transaction additions and removals can be staged and later discarded or applied. Additionally,
removals and additions are applied lazily, allowing them to be batched.

You can view the full [cluster mempool implementation PR](https://github.com/bitcoin/bitcoin/pull/28676) to see the usage of `TxGraph`
and how these new functions are used in the surrounding logic and contrast them with the existing code:

- [This commit](https://github.com/bitcoin-core-review-club/bitcoin/commit/f829febbb578a44c2a369ec307185eff9374e694)
  makes `CTxMemPoolentry` derive from `TxGraph::Ref`.
- Mempool validation [stages the addition of the new transaction(s) to a changeset](https://github.com/bitcoin-core-review-club/bitcoin/blob/682aab426e13d065a8c4a3e396e91e6ad4db0c35/src/validation.cpp#L899),
which stages changes to the mempool `TxGraph`.  To check cluster limits, it just
  [queries](https://github.com/bitcoin-core-review-club/bitcoin/blob/682aab426e13d065a8c4a3e396e91e6ad4db0c35/src/validation.cpp#L1347-L1350)
whether it is oversized. It no longer needs to know what the ancestor/descendant limits are or apply carveouts in a
replacement.
- RBF incentive compatibility simply entails
  [asking](https://github.com/bitcoin-core-review-club/bitcoin/blob/682aab426e13d065a8c4a3e396e91e6ad4db0c35/src/validation.cpp#L1017)
the `TxGraph` if the staged subgraph's feerate diagram improves upon the original feerate diagram.
- `PrioritiseTransaction`
  [now](https://github.com/bitcoin-core-review-club/bitcoin/blob/682aab426e13d065a8c4a3e396e91e6ad4db0c35/src/txmempool.cpp#L596)
just calls `TxGraph::SetTransactionFee()` and expects it to handle everything from there.
  [Before](https://github.com/bitcoin/bitcoin/blob/8fa10edcd1706a1f0dc9d8c3adbc8efa3c7755bf/src/txmempool.cpp#L913-L947),
it needed to iterate through all ancestors and descendants to update their cached fees.
- Additionally, prior to being queried for oversize or feerate diagrams, no cluster calculation and linearization is done.

Taking a look at PR #28676 can help illustrate some of the benefits of having `TxGraph`, including:

- The mechanical details of updating the dependency graph and its impact on incentive compatibility are abstracted away
  from higher level mempool logic.
  - `CTxMemPool`'s code is less cluttered with graph-wrangling logic. Lots of code is removed, and the much of the
    remaining ancestor/descendant tracking can be cleaned up in the future.
  - `TxGraph` doesn't know that it represents a mempool. It doesn't know what a transaction is, and
    doesn't care whether elements are being added and removed for replacements or block (dis)connection. It has a
smaller scope and well-specified behavior.
- We now have the ability to reason accurately about the addition of multiple transactions and removal of their
  collective replacements.
- Batched updates and linearization improve the overall performance of mempool operations.
- Deferred linearization also can allow for slower linearization improvements to be applied later, e.g. in the
  background, giving us the benefits of optimal linearizations without sacrificing performance.

### Implementation

The rest of the notes are about reviewing the PR itself. Advice on review approach:

- The author has written recommendations for reviewing the code [in this comment](https://github.com/bitcoin/bitcoin/pull/31363#issuecomment-2557349002).
- The PR is largely split into feature and optimization commits. The features are introduced iteratively, so it
may be easiest to review the PR in chunks of commits for each feature if the overall changes seem intimidating.
- Another approach is to first read through the overall changes to `TxGraph` and `TxGraphImpl`'s
  respective interfaces, and then review implementation. You could also review the interface, then
the fuzzer implementation, then the real implementation.

These notes are split by feature to make it easier to review the PR iteratively.

#### Basic TxGraph, Lazy and Oversized

This section includes code up to ["txgraph: (optimization) avoid per-group vectors for clusters & dependencies"](https://github.com/bitcoin-core-review-club/bitcoin/commit/5e55a584a77a8dfa357eaf016f177d72cb92a218).

A `TxGraph` has a vector of `Entry`s (where each entry is a single transaction), and a vector of `Cluster`s (which
represent clusters as defined earlier). Clients can `AddTransaction`, `RemoveTransaction`, `AddDependency`, and
`SetTransactionFee`. When a transaction is added, it starts in a cluster of its own. When `AddDependency` is called for
two transactions that are not already in the same cluster, their clusters are merged.

It also has queues of "work" to do which may or may not need to be completed in order to perform certain tasks or answer
external queries. Some tasks have other tasks as prerequisites.

This is the order in which things have to be resolved:

1. `ApplyRemovals`: Apply all of the queued removals.
2. `SplitAll`: Split up clusters if they contain components that are no longer connected to each other.
3. `GroupClusters`: Calculate what clusters would need to be merged if dependencies are applied. However, these changes are not yet applied.
4. `ApplyDependencies`: Apply new dependencies and merge clusters as computed in the previous step.
5. `Relinearize`: Relinearize clusters.

Much of the work is done lazily. For example, calling `RemoveTransaction` does not actually mean its etry is deleted, just that
the index has been added to `m_to_remove`. However, `TxGraph` cannot answer a call to `Exists` without first calling `ApplyRemovals`.

An **Oversized** `TxGraph` is one that has at least one cluster that violates the cluster count or size limits.
- A `TxGraph` only knows if it is oversized after it has completed steps 1-3.
- When a `TxGraph` is oversized, mutation functions (like `RemoveTransaction` and `AddDependency`) and
  `GetIndividualFeerate` can still be called, but inspection functions like `GetChunkFeerate` are unavailable because we won't
merge or linearize clusters that are oversized. (`GetChunkFeerate` becomes `GetMainChunkFeerate` in a later commit).
- Additionally, step 4 will not proceed if the `TxGraph` is oversized; step 5 is thus also impossible.

The `GroupClusters` function implements [union-find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure), a
favorite amongst software engineering interviewers.

<!-- FIXME: Unlinked -->

#### Staging Support

This section includes code up to ["txgraph: (optimization) cache oversizedness of graphs"](https://github.com/bitcoin-core-review-club/bitcoin/commit/12bc7e7e469f78aae8fced716aea2599f4ccb03e).

This feature allows users of `TxGraph` to stage changes and then apply or discard them, much like git.

Much of the `TxGraph` members are grouped together as a `ClusterSet`. This refactor is done so that a `TxGraph` can have multiple **subgraphs** or **levels** represented as
`ClusterSet`s: "main" (level 0) and "staged" (level 1).

By default, mutations like `AddTransaction`, `RemoveTransaction`, `AddDependency` are applied directly to main, but
clients of `TxGraph` can create a staging session:
- To [`StartStaging`](https://github.com/bitcoin-core-review-club/bitcoin/commit/79647fd58dc7152eb1dc4e09cc56db845608352d#diff-c25ebcc6e4dc9c9bb21462f796fbb470cee3f0ff1e77bfc4033f4e8460f4482cR1464),
a new subgraph is added containing copies of information from the main graph. It starts with no clusters and no
transactions.
- [Additions](https://github.com/bitcoin-core-review-club/bitcoin/commit/79647fd58dc7152eb1dc4e09cc56db845608352d#diff-c25ebcc6e4dc9c9bb21462f796fbb470cee3f0ff1e77bfc4033f4e8460f4482cR1249),
[removals](https://github.com/bitcoin-core-review-club/bitcoin/commit/79647fd58dc7152eb1dc4e09cc56db845608352d#diff-c25ebcc6e4dc9c9bb21462f796fbb470cee3f0ff1e77bfc4033f4e8460f4482cR1266-R1267),
and [new dependencies](https://github.com/bitcoin-core-review-club/bitcoin/commit/79647fd58dc7152eb1dc4e09cc56db845608352d#diff-c25ebcc6e4dc9c9bb21462f796fbb470cee3f0ff1e77bfc4033f4e8460f4482cR1285-R1286)
are automatically applied on the highest level: staged if it exists, main otherwise.
- To `CommitStaging`, everything is copied from staged to main after finding conflicting clusters and deleting them from
  main. Conflicting clusters include those belonging to all staged removals and any transactions the subgraphs have in common.
  Then, clusters, work queues, and statistics are copied from staged to main.
- `AbortStaging` largely consists of simply deleting the staged subgraph.

<!-- FIXME: more on impl -->

#### Specialized Functionality

This section includes the rest of [PR #31363](https://github.com/bitcoin/bitcoin/pull/31363),
but also [PR #31444](https://github.com/bitcoin/bitcoin/pull/31444) and [PR #31553](https://github.com/bitcoin/bitcoin/pull/31553).

There are various functions added to `TxGraph` to obtain specialized information.
It may be useful to look at the code surrounding mempool to understand why:
- `CountDistinctClusters` and `GetMainStagingDiagram` are used in RBF logic?
- `GetBlockBuilder` is used in block assembly?
- `GetWorstMainChunk` is used in mempool eviction?
- `Trim` is used in reorgs? It instructs `TxGraph` to delete transactions until it is no longer oversized,
  and allows it to decide which transactions to evict.

## Questions

#### Conceptual

1. Did you review the PR? [Concept ACK, approach ACK, tested ACK, or NACK](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#peer-review)?
What was your review approach?

1. What is the mempool "graph" and to what extent does it exist in the mempool code on master?

1. What are the benefits of having a `TxGraph`, in your own words? Can you think of drawbacks?

1. Can `TxGraph` help to more accurately calculate (and thus enforce) topology limits, or is it a just refactor?

#### Basic TxGraph, Lazy and Oversized

1. What is the difference between `TxGraph` and `Cluster`?

1. What does it mean for a `TxGraph` to be oversized? Is that the same as the mempool being full?

1. If a `TxGraph` is oversized, which functions can still be called, and which ones can't?

1. Under what circumstances could `GetIndividualFeerate` and `GetChunkFeerate` return an empty `FeeFrac`?
   Is it possible that one returns an empty `FeeFrac` and the other doesn't? How?
   (Note we are talking about pre-staging support code).

1. What are the 4 mutation functions? Which ones necessitate relinearization?

1. After calling `TxGraph::RemoveTransaction`, has the transaction been removed from `m_entries`? If not, what happens
   instead, and when are transactions removed from `m_entries`?

1. Why can't `ApplyDependencies` continue if the `TxGraph` is oversized?

1. Why isn't `Exists` a `const` function like one would expect?

1. What is the benefit of processing removals, dependencies, merges, and linearizations lazily?

1. Why is `AddTransaction` annotated with `[[nodiscard]]`?

1. For the `QualityLevel`s `NEEDS_RELINEARIZE`, `ACCEPTABLE`, and `OPTIMAL`, what can / can't {`TxGraph` internally, a
   client of `TxGraph`} do with a cluster that is linearized to that quality?

#### Staging Support

1. What is the purpose of `TxGraph` supporting the staging of update operations? In what situation
   would we use it, and do you think the benefits warrant the extra code complexity?

1. What are the `TxGraph` functions analogous to `git add`, `git commit`, and `git stash`? In the
   other direction, what is analogous to `AddTransaction`, `RemoveTransaction`, and `AddDependency`?

1. What does `PullIn` do, and when is it necessary? How many times can the `while (level < to_level)` loop run?

1. In the commit to "cache oversizedness," why is it ok that the `m_oversized` value for staged is [set](https://github.com/bitcoin-core-review-club/bitcoin/commit/12bc7e7e469f78aae8fced716aea2599f4ccb03e#diff-c25ebcc6e4dc9c9bb21462f796fbb470cee3f0ff1e77bfc4033f4e8460f4482cR1497) to that of main? Why is calling `SplitAll()` necessary?

1. How many levels are possible?

1. Which of the four combinations are possible {main, staged} {oversized, not oversized}?

#### Specialized Functionality

1. Why are these [specialized functions](#specialized-functionality) (`CountDistinctClusters`,
   `GetMainStagingDiagram`, `GetBlockBuilder`, `GetWorstMainChunk`, `Trim`) necessary? Can you think
   of a slimmer interface to serve these purposes?

1. What are all of the places where the mempool may need to evict transactions in order to stay
   within cluster limits?

1. Should `TxGraph` be allowed to decide which transactions to evict when it is oversized? Why or
   why not - does it depend on the situation?


## Meeting Log

{% irc %}
17:00 <glozow> #startmeeting
17:00 <stickies-v> hi
17:00 <glozow> Welcome to PR review club! Today is TXGRAPH DAY https://bitcoincore.reviews/31363
17:00 <glozow> If you say hi now you'll be in the logs ;)
17:00 <schmidty> hi
17:00 <marcofleon> hi!!!
17:01 <glozow> Did anybody get a chance to review the PR or look at the notes?
17:01 <kevkevin> hi
17:01 <stringintech> Hi!
17:01 <hernanmarino> Hi ! 
17:01 <alfonsoromanz> hi
17:01 <Polaris> hi
17:01 <jaruonic> hi
17:01 <Guest273> Yes, quickly went through the notes.
17:01 <kevkevin> I was able to look at the PR briefly to get a general idea of what it is trying to do
17:01 <hernanmarino> just the notes today, it looks interesting 
17:01 <sipa> hi
17:01 <stickies-v> i looked at the notes and linked resources, mostly!
17:01 <marcofleon> notes and a bit of review of the pr
17:01 <instagibbs> read the notes, played with the interface, started seriously looking through the commits today
17:01 <stringintech> Tried to figure out the overall structure through the PR description and header files.
17:02 <glozow> Great! hopefully we can get further today, as ultimately we want to be looking at the code
17:02 <glozow> Does anybody have any general cluster mempool questions before we dive in?
17:03 <abubakarsadiq> hi
17:03 <glozow> Ok. Feel free to ask questions whenever, since this is a text meeting
17:03 <glozow> What is the mempool “graph” and to what extent does it exist in the mempool code on master?
17:04 <Murch[m]> Hi
17:04 <marcofleon> in CTxMempoolEntry tx parents and descendants are kept track of... but there's no explicit graph
17:05 <jasan> to know the fees in order to make a heavy block template
17:05 <stringintech> Currently It exists as the ancestor-dependant connections and no such thing as clusters.
17:05 <stringintech> descendant*
17:06 <sipa> marcofleon: well, arguably txgraph doesn't change that... there is still just the set of ancestors and descendants for each transaction there, but it's better encapsulated, and uses more efficient data structures
17:06 <kevkevin> What I understand is its the mempool entries and their parents and descendants 
17:06 <abubakarsadiq> list of all the transactions where connected ones form a single graph where a node in the graph represent a tx
17:06 <stickies-v> the nodes of the graph are the `CTXMemPoolEntry` objects, and the edges are are all their ancestor/dependant connection
17:06 <glozow> Right. When we need to know the ancestors of a transaction, what do we do? Bonus points if you can link me a code example
17:07 <sipa> glozow: in the current master code, i assume you mean?
17:07 <marcofleon> right, that makes sense
17:07 <glozow> yes on master
17:08 <glozow> (will also happily accept an answer that is for calculating the descendant set)
17:09 <stringintech> Have not check out the code but recursively look up parents of all the parents of the tx?
17:09 <abubakarsadiq> you have to recursively find parent of the transactions parents
17:09 <CosmikDebris> https://github.com/bitcoin/bitcoin/blob/a43f08c4ae3235f2fa460dd17a7f5f9f9842efd9/src/txmempool.cpp#L243 invoke `CalculateMemPoolAncestors`
17:09 <stickies-v> recursively use `GetMemPoolParents` and `GetMemPoolChildren`?
17:09 <Guest273>     virtual std::vector<Ref*> GetAncestors(const Ref& arg, bool main_only = false) noexcept = 0; ?
17:10 <sipa> Guest273: that's in the PR; the question is how it works in master today
17:10 <kevkevin> Do we calculate using this function? CTXMemPool::CalculateMemPoolAncestors()
17:10 <marcofleon> CTxMemPool::CalculateMemPoolAncestors gotta be involved
17:10 <glozow> stringintech: abubakarsadiq: stickies-v: yep!
17:10 <marcofleon> haha seems to be a lot
17:10 <glozow> CMPA yep
17:10 <glozow> https://github.com/bitcoin/bitcoin/blob/a43f08c4ae3235f2fa460dd17a7f5f9f9842efd9/src/txmempool.cpp#L172-L200 here's the loop
17:11 <glozow> and descendants: https://github.com/bitcoin/bitcoin/blob/a43f08c4ae3235f2fa460dd17a7f5f9f9842efd9/src/txmempool.cpp#L571-L593
17:11 <glozow> What are the benefits of having a TxGraph, in your own words? Can you think of drawbacks?
17:12 <glozow> These should be pros that we *don't* already have today
17:12 <marcofleon> Just more structured and better encapsulated as sipa said previously. Makes it easier to reason about. Also the atomic operations with staging seems like a good approach. I'm not sure if we do something like that today?
17:12 <stringintech> First thing I noticed when looking at the code was how relatively easy it was to understand things. Even not knowing the previous logic.
17:13 <stringintech> As a first-timer.
17:13 <abubakarsadiq> many benefits, we now group connected transactions into clusters, we maintain the list of this clusters, which make it easy for getting ancestors of transaction, linearization, maintaining cluster size, mining and eviction
17:13 <kevkevin> ya I'd say it makes it easier to reason about the the structure of the graph
17:14 <sipa> as for comparison with *today*, i think the answer is primarily that it brings in all of the cluster mempool goodness: chunk feerates, linearizations, the ability to observe a full ordering of transactions in the mempool
17:14 <instagibbs> marcofleon currently we have no great way of "simualting" entry and testing, so you get weird things in the code in mayn places
17:14 <marcofleon> got it
17:14 <sipa> as for comparison with a theoretical alternative where cluster mempool was brought it, without an intermediary layer that models the transaction graph: encapsulation, and the fact that it's fully specified (almost...) which significantly increases the power of tests for it
17:15 <instagibbs> marcofleon https://github.com/bitcoin/bitcoin/blob/master/src/validation.cpp#L951 f.e.
17:15 <glozow> I really like that it abstracts away all the topological details so e.g. validation isn't trying to figure out how to not double-count replacements and combine package/mempool ancestors etc
17:15 <glozow> Also it can do that accurately, instead of doing ugly carveouts to try to guess
17:16 <glozow> biggest offender imo https://github.com/bitcoin/bitcoin/blob/a43f08c4ae3235f2fa460dd17a7f5f9f9842efd9/src/validation.cpp#L950-L984
17:16 <marcofleon> The carveouts are indeed ugly
17:17 <glozow> sipa: ooh, making a mental note to ask "which parts are not specified?" later
17:17 <sipa> though to be fair, getting rid of the carveout isn't a benefit of this approach
17:17 <glozow> why not?
17:17 <sipa> it's a choice we make, because it is a policy rule which is incompatible with the approach we want
17:17 <sipa> we could do it without this PR
17:18 <glozow> sipa: you seem to be thinking of cpfp carve out
17:18 <glozow> I'm talking about RBF carve out?
17:18 <sipa> oooh, sorry, i didn't check the link!
17:18 <instagibbs> there are multiple carveouts :(
17:18 <sipa> you are right
17:18 <sipa> i didn't know that was also called carvout
17:19 <instagibbs> very long comment in the code too, gives confidence to quality of design
17:19 <glozow> can anybody think of any drawbacks? :)
17:20 <sipa> we have to do annoying review clubs about it? ;)
17:20 <instagibbs> drawbacks to txgraph?
17:20 <glozow> so, complexity? haha
17:20 <glozow> but encapsulated complexity!
17:20 <sipa> i guess that's the most obvious answer... it's a very non-trivial amount of code that needs review
17:21 <marcofleon> 0 drawbacks for sure... no i guess some overhead with all the additional data structures? but I think the encapsulation and the fact that its much easier to test makes it worth it
17:21 <jasan> what about tx prioritization, is is retained with the cluster look at mempool?
17:22 <jasan> I mean RPC prioritizetransaction
17:22 <sipa> jasan: yes, it is independent, as that lives on a higher level
17:22 <abubakarsadiq> @marcofleon the additional data structures are mostly not drawbacks IIUC some are fixing current issues
17:22 <instagibbs> jasan SetTransactionFee see that
17:22 <monlovesmango> it might me more overhead to just get direct ancestor/child?
17:22 <glozow> jasan: yes, that's what `SetTransactionFee` is for
17:22 <schmidty> jasan: TxGraph::SetTransactionFee()
17:22 <stickies-v> wrt drawbacks: I suppose encapsulation sometimes doesn't allow you to make certain (hacky) performance optimizations without changing the interface?
17:22 <jasan> prioritisetransaction
17:23 <jasan> sipa: thanks
17:23 <abubakarsadiq> like `FeeFrac` it fixes the rounding error of  `CFeeRate`
17:23 <sipa> jasan: in the PR description i state that TxGraph doesn't know about prioritization; that doesn't mean it's incompatible with it - the point is just that it doesn't *care* why the mempool things a particular transaction has a particular fee, but it's perfectly possible for the mempool to apply prioritization before handing fees to txgraph (and will)
17:24 <marcofleon> abubakarsadiq: nice yeah that makes sense. I still need to understand a lot of the lower level pros
17:24 <glozow> the only thing I can think of it is that it's sometimes nice for validation to get to dictate what topology limits are per-tx, e.g. with TRUC and other imagined policies https://delvingbitcoin.org/t/v3-and-some-possible-futures/523
17:25 <sipa> monlovesmango: there is indeed some overhead, though it's tiny (and probably well-compensated by using more efficient data structures internally)... the fact that transaction references always need to be translated from/to TxGraph::Ref* pointers is a runtime cost throughout the design
17:25 <instagibbs> glozow I kind of imagine we'd be able to clean up TRUC logic with txgraph though, even without txgraph driving the logic itself
17:26 <glozow> instagibbs: how?
17:26 <instagibbs> maybe after the hour 👍
17:26 <sipa> glozow: no reason why functionality for testing for particular topologies can't be added to txgraph, but the abstraction does mean there is an extra cost
17:26 <glozow> was thinking about some of the whiteboarding we did on limiting direct parents/children
17:27 <glozow> fosho doable. I'm just trying to come up with something to put on this side of the chart 😂 
17:27 <glozow> Ok let's look at implementation
17:27 <glozow> What is the difference between `TxGraph` and `Cluster`?
17:28 <CosmikDebris> clusters are connected components, the graph is a DAG
17:28 <marcofleon> txgraph is the full set of transactions and their relationships. cluster is a group of connected txs within the txgraph
17:28 <monlovesmango> TxGraph holds all transaction refs, clusters are assigned to each transaction
17:29 <sipa> bonus questions: how many Clusters can an individual transaction be part of, within a TxGraph?
17:29 <monlovesmango> one
17:29 <monlovesmango> ?
17:30 <schmidty> 2
17:30 <sipa> monlovesmango: depends which commit we're looking at, but initially, indeed 1
17:30 <instagibbs> monlovesmango Refs are held by the user of TxGraph, I think "Entry" is the terminlogy?
17:30 <stringintech> maybe 2 considering the staging changes?
17:30 <sipa> stringintech, schmidty: eventually, indeed 2
17:30 <marcofleon> 2 i think yeah. with staging graph and main graph?
17:31 <abubakarsadiq> 1 to externals, 2 within
17:31 <sipa> abubakarsadiq: well, Cluster is entirely within
17:31 <monlovesmango> if the question is within a single TxGraph it should be 1 right? staging and main are different TxGraphs?
17:31 <sipa> monlovesmango: incorrect, TxGraph encapsulates both the main graph, and optionally a staging graph
17:31 <monlovesmango> ok thank you!
17:32 <glozow> is it possible for a transaction to never be in a singleton Cluster?
17:32 <sipa> glozow: nice one
17:32 <glozow> (singleton Cluster means there is only 1 tx in the cluster)
17:32 <instagibbs> I don't think so
17:33 <abubakarsadiq> I think no, each transaction has to be added individually first
17:33 <instagibbs> AddTransaction says: "/ Construct a new singleton Cluster (which is necessarily optimally linearized)."
17:33 <stickies-v> aren't operations batched?
17:33 <monlovesmango> how would anchor txs be processed?
17:33 <monlovesmango> *ephemeral anchor txs
17:33 <glozow> stickies-v: good point! let's look at `AddTransaction` https://github.com/bitcoin-core-review-club/bitcoin/blob/3c7732bbbe735d1883cdd1737ec200cab8caa049/src/txgraph.cpp#L1305
17:34 <sipa> stickies-v: they are, but transaction additions are not (only removals and dependency additions are batched)
17:34 <glozow> Looks like we immediately make a cluster for it, so batching doesn't change this
17:34 <glozow> So every entry has to be a singleton at some point
17:34 <instagibbs> monlovesmango TxGraph is unaware of what an anchor is, it just knows there are at least two transactions, one depending on another
17:34 <instagibbs> at given feerates
17:35 <monlovesmango> got it, thanks :)
17:35 <glozow> `TxGraph` doesn't even know what a transaction is
17:35 <glozow> What does it mean for a TxGraph to be oversized? Is that the same as the mempool being full?
17:35 <CosmikDebris> it means at least one of its clusters exceeds size limits
17:35 <abubakarsadiq> @monlovesmango You add the parent, then add the child, then add the dependency between them
17:36 <marcofleon> its not the same as mempool being full. txgraph being oversized means that at least one cluster exceeds max_cluster_count_limit
17:36 <monlovesmango> it means at least one cluster is exceeding the size limits
17:36 <marcofleon> also txgraph not even knowing what a transaction is is cool
17:36 <glozow> marcofleon: monlovesmango: yep exactly. can be oversized and not full. Can be full and not oversized.
17:37 <abubakarsadiq> unclear to me what next to do txgraph is oversized? what are cant you do at that state
17:38 <instagibbs> monlovesmango size(weight/vbytes) and count (number of txns)
17:38 <glozow> abubakarsadiq: what's the question? are you asking what a client should do if they see that it's oversized?
17:38 <hernanmarino> marcofleon: +1
17:38 <kevkevin> There is a function TxGraphImpl::IsOversized to determine if the txgraph is oversized
17:38 <marcofleon> correct if i'm wrong but I feel Abubakar is asking the. next q in the notes essentially?
17:39 <marcofleon> like what can and can't be done
17:39 <sipa> the interface in txgraph.h should be properly documented with which things you can do while oversized and which you cannot
17:39 <glozow> If a TxGraph is oversized, which functions can still be called, and which ones can’t?
17:40 <schmidty> Functions that query cannot be called, presumably for performance, or?
17:40 <marcofleon> all 4 mutations can be called still
17:40 <CosmikDebris> you can't call stuff that depends on linearizing clusters, like computing chunk feerates
17:40 <sipa> schmidty: no, because oversized clusters internally just cannot be _represented_, so if there are batched operations present which would require an oversized Cluster to be created, they just don't get applied, and instead the TxGraph goes into "oversized" state
17:40 <kevkevin> I see that ApplyDependencies cannot be called if oversized
17:40 <sipa> CosmikDebris: not just linearization!
17:41 <instagibbs> anything that involves larger than O(1)-ish work, I think
17:41 <instagibbs> (can't be)
17:41 <sipa> schmidty: so we solve that by outlawing any operations that could require actually materializing an oversized cluster
17:41 <glozow> to linearize, first you must merge clusters. to merge clusters, you must first ensure you will not be creating a cluster that is too big
17:41 <instagibbs> can't even ask for vector of Refs from cluster
17:41 <stringintech> I had a relevant question. What causes the TxGraph to be not oversized anymore? Only tx removal/evict?
17:41 <schmidty> sipa: thanks!
17:42 <sipa> stringintech: bingo, or if the oversizedness is restricted to a staging graph, AbortStaging() will fix it too (by just throwing it away)
17:42 <glozow> stringintech: yes, you can `RemoveTransaction`. Or you can `AbortStaging` ("I've decided not to accept this tx to mempool")
17:42 <glozow> can `main` be oversized?
17:42 <sipa> instagibbs: i think the threshold is anything that requires O(n^2) work or more (which includes computing the ancestors/descendants of a transaction)
17:43 <sipa> instagibbs: the last PR's TxGraph::Trim function is roughly O(n log n), and can be used in oversized state
17:43 <glozow> Under what circumstances could GetIndividualFeerate and GetChunkFeerate return an empty FeeFrac? Is it possible that one returns an empty FeeFrac and the other doesn’t?
17:44 <stringintech> sipa: glozow: Thanks!
17:44 <instagibbs> sipa fair enough
17:44 <glozow> marcofleon: you mentioned "4 mutations", what are they?
17:45 <monlovesmango> both return empty if tx doesn't exist in txgraph. chunk can return empty when individual does not when oversized
17:45 <marcofleon> AddTransaction, RemoveTransaction, AddDependency, and SetTransactionFee
17:45 <kevkevin> glozow arent they AddTransaction RemoveTransaction AddDepndency and SetTransactionFeeRate?
17:46 <sipa> monlovesmango: GetChunkFeerate is just *not allowed* to be called when oversized, so talking about its correctness or what it would return isn't really well-defined
17:46 <monlovesmango> sipa: oh right!
17:47 <glozow> kevkevin: marcofleon: great. and why can we keep calling them when oversized?
17:48 <marcofleon> could chunkfeerate return empty beacuse MakeAcceptable fails while individualfeerate would be fine?
17:48 <marcofleon> was just trying to answer the second part there but not quite sure
17:48 <sipa> monlovesmango: MakeAcceptable cannot fail
17:48 <glozow> What do you have to do before you know chunk feerate?
17:48 <sipa> eh, marcofleon
17:48 <stringintech> glozow: I guess after the mutations it could be not oversized anymore
17:48 <marcofleon> thanks, need to look at that more
17:49 <sipa> marcofleon: or rather, if it might fail, you're just not allowed to call anything that needs MakeAcceptable (because that implies you're oversized)
17:50 <kevkevin> stringintech: if we're using the AddTransaction mutation would it not still be oversized?
17:50 <sipa> yeah, only RemoveTransaction can result in changing oversized -> not oversized
17:51 <sipa> adding transactions or adding dependencies can only result in going the other way
17:51 <glozow> the answer I was looking for is essentially: txgraph is oversized but also lazy (wow that's kind of mean to say) and none of the mutation functions synchronously do cluster merging or linearization
17:51 <sipa> exactly ^
17:51 <glozow> For example: After calling `TxGraph::RemoveTransaction`, has the transaction been removed from `m_entries`?
17:51 <hernanmarino> glozow:  :))
17:52 <instagibbs> added to m_to_remove
17:53 <stringintech> Earlier glozow: asked if `main` can be oversized too which became my question too :)) I guess it was not answered or I missed the answer.
17:53 <glozow> yep: https://github.com/bitcoin-core-review-club/bitcoin/blob/3c7732bbbe735d1883cdd1737ec200cab8caa049/src/txgraph.cpp#L1327
17:53 <stringintech> kevkevin: right.
17:53 <glozow> what about `AddDependency`, what happens instead of merging clusters? https://github.com/bitcoin-core-review-club/bitcoin/blob/3c7732bbbe735d1883cdd1737ec200cab8caa049/src/txgraph.cpp#L1344
17:53 <sipa> stringintech: what do you think the answer is? can main be oversized?
17:54 <glozow> :)
17:54 <stringintech> As far as I saw in the code (not deep enough though), operations were happening on the upmost clusterset. So if we do not have staging the main could be oversized.
17:55 <marcofleon> Is the tx actually removed when Compact is called?
17:55 <sipa> marcofleon: define "tx actually removed"
17:55 <sipa> the Ref? the Entry? the state of the Locator?
17:56 <marcofleon> hmm yeah... i guess removed from m_entries
17:56 <sipa> marcofleon: right, what happens to the Ref then?
17:57 <glozow> stringintech: yes, it depends on usage. Intended usage is to first stage changes and discard them if they result in an oversized txgraph. But you can also apply things directly to main and make it oversized
17:57 <stringintech> glozow: Thank you
17:57 <glozow> `TxGraph`, at least, does not stop you from doing this
17:58 <kevkevin> I think it can be oversized if we don't have the staging txgraph? since then m_clustersets.size() - 1 = 0
17:58 <kevkevin> the main txgraph
17:58 <marcofleon> The Ref stays i believe...
17:58 <sipa> stringintech: in practice (after follow-up PRs to make the mempool code actually use txgraph), staging will be used for rbf evaluations, while main will be used directly from blocks... and a reorg can add transactions back to the mempool, which could temporarily cause main to be oversized
17:58 <abubakarsadiq> sipa: I think the ref was removed already
17:58 <sipa> abubakarsadiq: bingo
17:58 <marcofleon> oh. Hmm okay
17:59 <glozow> does `CommitStaging` stop you from committing changes that would make `main` oversized?
17:59 <sipa> marcofleon: sorry, it was a trick question (actually, i just forgot that had changed recently), Entrys are not removed from m_entries until the Ref is destructed
17:59 <stringintech> sipa: Hmmm. Thanks!
17:59 <monlovesmango> glozow: no doesn't look like it
17:59 <glozow> https://github.com/bitcoin-core-review-club/bitcoin/blob/3c7732bbbe735d1883cdd1737ec200cab8caa049/src/txgraph.cpp#L1600
17:59 <marcofleon> Got it thanks. Trick questions are how we learn!
17:59 <glozow> Ah we are out of time!
18:00 <jasan> Thank you all!
18:00 <kevkevin> Thank you guys!
18:00 <monlovesmango> thank you glozow, sipa, and all!!
18:00 <glozow> Do people want to do another meeting? I am not free at this time tomorrow, but if somebody else wants to run it...?
18:00 <abubakarsadiq> thanks for hosting and the nice docs @glozow
18:00 <stringintech> Thanks for making life easier for first-timers :))
18:00 <sipa> thanks glozow for hosting, and thanks everyone for taking some time to look at my PRs
18:00 <jasan> https://alt.signetfaucet.com/ - TRUC related
18:00 <marcofleon> Thanks glozow and sipa! Good stuff
18:00 <monlovesmango> learned a lot :)
18:00 <hernanmarino> thanks ! 
18:00 <algo2043> thanks!
18:01 <glozow> We could also meet again next week
18:01 <stickies-v> thank you for hosting and your awesome prep work glozow !
18:01 <hernanmarino> next week is better i think 
18:01 <glozow> #endmeeting
{% endirc %}
